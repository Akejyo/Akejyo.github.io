---
title: TX·IEG菁英班3期作业wp
date: 2023-12-9
categories: [Study, Re]
tags: [MISC, Re]
math: true
image:
  path: /img/tx_fen.png
  alt: ~~~
---



# TX·IEG菁英班3期作业wp

## 第一次作业

给了一个 `crackme.exe`，运行出现一个命令行界面：

![image-20231209021740185](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209021740185.png)

题目要求：

1. 使用Windows API `CreateRemoteThread` 远程注入模块到 crackme 进程中并且不崩溃，然后使用 ark 工具(例如 processhacker 等)能够查看注入模块的信息；
2. 分析并调试程序，找到正确的flag；
3. 利用注入的DLL ，Hook程序代码：通过Hook进程中的函数使得输入任何字符串，控制台都会打印“正确”.

***

### 1.

首先要找到进程 pid，可以通过进程名称找到其 pid

先取一个进程快照，然后循环遍历找进程，获得其 pid

```cpp
bool FindProcess(const wchar_t* processName, DWORD& dwProcess) {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // 获得进程快照
    if (hProcessSnap == INVALID_HANDLE_VALUE) return false;         // 检查是否有效

    pe32.dwSize = sizeof(PROCESSENTRY32);       // 初始化大小
    if (!Process32First(hProcessSnap, &pe32)) { // 获取hProcessSnap的第一个进程
        CloseHandle(hProcessSnap);
        return false;
    }
    do {                                                // 循环遍历所有快照
        if (wcscmp(pe32.szExeFile, processName) == 0) { // 名称一致
            dwProcess = pe32.th32ProcessID;
            CloseHandle(hProcessSnap);
            return true;
        }
    } while (Process32Next(hProcessSnap, &pe32));
    CloseHandle(hProcessSnap);
    return false;
}
```

注入主体部分：

1. 打开进程对象

   ```cpp
   HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcess);
   ```

   OpenProcess 函数用来打开一个已存在的进程对象，返回进程的句柄 [OpenProcess function ](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)

2. ```cpp
   LPVOID allocatedMem = VirtualAllocEx(hProcess, NULL, sizeof(myDLL), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); 
   ```

   在目标进程中分配内存存储DLL的路径，单纯就是分配一个路径的大小的空间，返回已分配页区域的基址  [VirtualAllocEx function](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)

3. ```cpp
   WriteProcessMemory(hProcess, allocatedMem, myDLL, sizeof(myDLL), NULL)
   ```

   向进程写入DLL路径 [WriteProcessMemory function](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)

4. 进程注入最核心的部分就是用 Windows API，在目标进程上开一个线程调用 LoadLibrary 函数加载我们自己的dll。kernel32.dll是一个 Windows 的核心动态链接库文件，提供大量 Windows API，是 Windows 必有的动态库文件，大多数进程都会调用 kernel32.dll，先获得一下句柄：

   ```cpp
   GetModuleHandle(TEXT("kernel32.dll"))
   ```

   然后找到 LoadLibrary 的首地址：

   ```cpp
   FARPROC pLoadLibraryA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
   ```

   最后使用 [CreateRemoteThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread) 函数开一个线程：

   ```cpp
   HANDLE hThread = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, allocatedMem, 0, 0);
   ```

完整主函数代码如下，还包含了提权的部分：

```cpp
#include <bits/stdc++.h>
#include <windows.h>
#include <TlHelp32.h>
#include <tchar.h>

using namespace std;

bool FindProcess(const wchar_t* processName, DWORD& dwProcess) {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // 获得进程快照
    if (hProcessSnap == INVALID_HANDLE_VALUE) return false;         // 检查是否有效

    pe32.dwSize = sizeof(PROCESSENTRY32);       // 初始化大小
    if (!Process32First(hProcessSnap, &pe32)) { // 获取hProcessSnap的第一个进程
        CloseHandle(hProcessSnap);
        return false;
    }
    do {                                                // 循环遍历所有快照
        if (wcscmp(pe32.szExeFile, processName) == 0) { // 名称一致
            dwProcess = pe32.th32ProcessID;
            CloseHandle(hProcessSnap);
            return true;
        }
    } while (Process32Next(hProcessSnap, &pe32));
    CloseHandle(hProcessSnap);
    return false;
}

bool EnableDebugPrivilege() { // 提权
    HANDLE token;
    TOKEN_PRIVILEGES tp;
    // 打开进程令牌环
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token)) {
        cout << "打开进程令牌失败" << endl;
        return false;
    }
    //  获取进程本地唯一ID
    LUID luid;
    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {
        cout << "获取LUID失败" << endl;
        return false;
    }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    tp.Privileges[0].Luid = luid;
    // 调整进程权限
    if (!AdjustTokenPrivileges(token, 0, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
        cout << "提权失败" << endl;
        return false;
    }
    return true;
}

void CreateRemoteThread_inject() {
    DWORD dwProcess;
    char myDLL[] = "E:\\vs\\test\\x64\\Debug\\test.dll";
    if (FindProcess(L"crackme.exe", dwProcess)) {
        cout << dwProcess << endl;

        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcess);
        LPVOID allocatedMem = VirtualAllocEx(hProcess, NULL, sizeof(myDLL), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); // 在目标进程中分配内存存储DLL的路径
        if (!WriteProcessMemory(hProcess, allocatedMem, myDLL, sizeof(myDLL), NULL)) {
            cout << "写入DLL路径失败" << endl;
            cout << GetLastError() << endl;
        };
        FARPROC pLoadLibraryA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
        HANDLE hThread = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, allocatedMem, 0, 0);
        if (!hThread) {
            cout << "创建线程失败" << endl;
            cout << GetLastError() << endl;
        };
        CloseHandle(hThread);
        CloseHandle(hProcess);
    }
}
int main() {
    if (!EnableDebugPrivilege()) {
        cout << "提权失败" << endl;
        return 0;
    }
    CreateRemoteThread_inject();
    int tmp;
    cin >> tmp;
    return 0;
}
```

接下来是我们要注入的 dll，dll 工程如何建立可简单搜索到，下面的 dllmain.cpp 就是用来生成 dll 的

dllmain.cpp代码

```cpp
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
DWORD WINAPI ThreadProc(){
    MessageBox(NULL, L"注入成功", L"1", 0);
    return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, NULL, 0, NULL);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

需要注意的是，主函数生成的 exe 和 `dllmain.cpp` 生成 dll 都必须和 `crackme.exe ` 的平台保持一致，即都是64位。比较坑的是 vs 默认是 32位，被这个坑了巨久。

先运行 `crackme.exe` 然后运行主函数的程序，结果如下：

![image-20231209022427403](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209022427403.png)

成功找到 crackme 进程（pid 29344），并向 crackme 进程注入了 `test.dll`，显示了一个消息框

***

### 2.

ida 打开，字符串啥的都搜了一波，啥也没发现.

进入 `main` 函数，里面就一个函数 `sub_1400014D0`，再进去看看，一波断点调试后发现了输出输入函数是什么

```cpp
  sub_140001020(&v34);
  CreateThread(0i64, 0i64, StartAddress, 0i64, 0, 0i64);
  sub_140001070(&unk_140025600, v37);
```

其中 `sub_140001020` 是输出函数，这里是打印"请输入flag："

![image-20231209023325240](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209023325240.png)

然后 `sub_140001070` 是输入函数，输入的字符串保存到v37

既然知道输出输入了就容易读代码了，再往下找输出函数

```cpp
  v31 = v37;
  do
  {
    v32 = (unsigned __int8)*(v31 - 48);
    v33 = (unsigned __int8)*v31 - v32;
    if ( v33 )
      break;
    ++v31;
  }
  while ( v32 );
  if ( v33 )
    v34.m128i_i32[0] = -872817740;
  else
    v34.m128i_i32[0] = -1879061547;
  v34.m128i_i16[2] = 3338;
  *(__int16 *)((char *)v34.m128i_i16 + 1) ^= 0x3736u;
  v34.m128i_i8[3] ^= 0x38u;
  v34.m128i_i8[6] = 0;
  sub_7FF7891B1020(&v34);
```

v37 是刚才输入的字符串，这里赋值给了 v31.

然后一顿循环，用 v33 作分支条件，断点调试可以知道 -1879061547 对应的是正确， -872817740 对应的是错误，也就是说我们要让 v33 为 0.

再看看那个循环，48很有迷惑性（'0'的ascii），但仔细一看会发现它是直接用v31字符串指针去减48，这一减岂不是就跑到其他内存地方去了，断点调试看看：

![image-20231209023800316](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209023800316.png)

这里asd是我随便输入的字符串，往上找48位：

![image-20231209023835070](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209023835070.png)

flag：`HiGWDUuXQS6wVHBTp0ERfJe6VqprMqD1`

***

### 3.

由2可以知道这个程序的逻辑了，想要一直输出正确也很简单，直接在那个 if 分支做手脚就好，断点调试到那个分支：

![image-20231209024146350](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024146350.png)

这里先 test 了一下，然后 jnz 做分支跳转，到 ce 看看：

![image-20231209024348777](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024348777.png)

那就很明显了，理论上我直接把 18e7 和 18e9 这两个换 nop 就行

![image-20231209024456266](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024456266.png)

![image-20231209024521183](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024521183.png)

然后再利用刚才在1里写的 dll 注入，直接重写一下 dllmain：

```cpp
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include <windows.h>
#include <bits/stdc++.h>
using namespace std;
void HookJNE(void* pJNE) {
    DWORD oldProtect;
    VirtualProtect(pJNE, 4, PAGE_EXECUTE_READWRITE, &oldProtect); //4个nop，分配4
    *(DWORD*)pJNE = 0x90909090; // 换入nop nop nop nop
    VirtualProtect(pJNE, 4, oldProtect, &oldProtect);
}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD ul_reason_for_call,
    LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH: {
        HMODULE hCrackMe = GetModuleHandle(TEXT("crackme.exe")); //获得基地址
        if (hCrackMe != NULL) {
            HMODULE jneAddress = (HMODULE)((size_t)hCrackMe + 0x18E7);
            HookJNE((void*)jneAddress);
        }
    } break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

然后就和1一样即可

***

## 第二次作业

给了一个 `crackme1.apk`，丢到虚拟机运行是一个输入字符串的界面，输入字符串点击确认会弹出 toast 消息 "wrong" 或者 "right"

题目要求：

1. 使用ptrace技术远程注入模块到crackme1进程中并且不崩溃，然后使用如下命令在远程进程中能够查看注入模块的信息；
2. 通过hook进程中的函数使得输入任何字符串，点击确认都会弹出toast消息”right”.

***

遇到很多环境什么的问题，放点链接：

[Android SDK Tools 安装时找不到JDK](https://blog.csdn.net/qq_48016058/article/details/113869661#:~:text=今天 安装Android studio 的 时 候发现 安装 程序,Files Java  jdk 1.7.0_21”了。 （这个地方一定要设置 JAVA —HOME%2C使用直接赋)

[安卓模拟器简介和adb使用](https://blog.csdn.net/weixin_42311335/article/details/112136351)

***

