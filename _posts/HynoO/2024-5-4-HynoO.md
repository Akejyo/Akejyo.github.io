---
title: "HynoO ç½‘ç»œèŠå¤©å®¤"
date: 2024-5-5
categories: [Recreation, HynoO]
tags: [Rust, React]
image:
    path: /img/image-20240505002954186.png
---

ä½¿ç”¨ Rust ä½œæœåŠ¡ç«¯ï¼ŒåŸºäº WebSocket çš„ç±» IRC ç½‘ç»œèŠå¤©å®¤

<!-- more -->

# HynoO ç½‘ç»œèŠå¤©å®¤

> *ä¸ºä»€ä¹ˆåšè¿™ä¸ªï¼Ÿ*
>
> * ä¹…ä»° Rust å¤§åï¼Œè™½ç„¶æˆ‘å¯¹ Rust ä»€ä¹ˆéƒ½ä¸çŸ¥é“ï¼Œæ¢—å›¾å€’æ˜¯çœ‹äº†ä¸€å †ï¼Œå¿ä¸äº†ä¸€ç‚¹ï¼Œå­¦å­¦çœ‹ğŸ¦€ã€‚
>
>   <img src="E:\Akejyo.github.io\_posts\HynoO\assets\image-20240505143244955.png" alt="image-20240505143244955" style="zoom:50%;" />
>
> * ä»æˆ‘å¤§ä¸€ç¬¬ä¸€æ¬¡æ¥è§¦ç½‘ç«™åˆ¶ä½œæ—¶ï¼Œç½‘ç»œèŠå¤©å®¤ä¸€ç›´æ˜¯æˆ‘è€ƒè™‘çš„ä¸€ä¸ªä¸œè¥¿ã€‚æ— å¤´éª‘å£«å¼‚é—»å½•é‡Œçš„åŒ¿åèŠå¤©å®¤ DOLLARSï¼ŒLain é‡Œçš„è¿çº¿ä¸–ç•Œï¼Œä»¥åŠåœ¨å°è¯• CTF æ—¶äº†è§£åˆ°é»‘å®¢åŒ¿åèŠå¤©ç½‘ç«™ HackChat ç­‰ç­‰ï¼Œå…„å¼Ÿï¼ŒçœŸçš„å¸…ã€‚

## ç®€å•ä»‹ç» WebSocket

â€‹	é€šå¸¸è€Œè¨€ï¼ŒWeb åº”ç”¨é‡‡ç”¨è½®è¯¢çš„æ–¹å¼å®ç°æ¨é€ï¼Œå³æµè§ˆå™¨æ¯éš”ä¸€æ®µæ—¶é—´å‘æœåŠ¡å™¨å‘é€ HTTP è¯·æ±‚ï¼Œç„¶åæœåŠ¡å™¨å¤„ç†ä¿¡æ¯å¹¶è¿”å›ç»™æµè§ˆå™¨ã€‚è¿™ç§æ–¹å¼ï¼ˆHTTP åè®®ï¼‰çš„é—®é¢˜åœ¨äºï¼Œå¿…é¡»ç”±å®¢æˆ·ç«¯å»å‘èµ·è¯·æ±‚ï¼Œæµè§ˆå™¨ç”¨å›ºå®šé¢‘ç‡å»è¯·æ±‚æœåŠ¡å™¨ï¼Œä¸ä»…å®æ—¶æ€§ä¸å¤Ÿï¼Œè€Œä¸”å®¹æ˜“é€ æˆèµ„æºæµªè´¹ã€‚

â€‹	WebSocket æ˜¯ HTML5 å¼€å§‹æä¾›çš„ä¸€ç§åœ¨å•ä¸ª TCP è¿æ¥ä¸Šè¿›è¡Œçš„å…¨åŒå·¥é€šè®¯åè®®ï¼ŒæœåŠ¡å™¨å¯ä»¥ä¸»åŠ¨å‘æ¶ˆæ¯ç»™å®¢æˆ·ç«¯ã€‚å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨å»ºç«‹è¿æ¥åï¼ŒåŒæ–¹å³å¯äº’ç›¸å‘é€æ¶ˆæ¯ï¼Œè€Œä¸éœ€è¦å‘ HTTP åè®®é‚£æ ·è¯·æ±‚

â€‹	å®¢æˆ·ç«¯çš„ WebSocket è¿æ¥æŠ¥æ–‡ä¸­æœ‰ `Upgrade: websocket` å­—æ®µï¼Œæ›´è¯¦ç»†çš„å±æ€§ä»‹ç»å¯è§[WebSocket - Web API | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)

## ä»€ä¹ˆæ˜¯ IRC

â€‹	IRC (Internet Relay Chat)ï¼Œæ˜¯ä¸€ç§åº”ç”¨å±‚çš„åè®®ï¼Œä¸»è¦ç”¨æ¥ç¾¤ä½“èŠå¤©ã€‚å…¶åŸç†éå¸¸ç®€å•ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸ªå¹¿æ’­è¿‡ç¨‹ã€‚IRC ç”¨æˆ·ä¸æœåŠ¡å™¨è¿æ¥åï¼Œå‘æœåŠ¡å™¨å‘é€æ¶ˆæ¯ï¼ŒæœåŠ¡å™¨ä¼šæŠŠæ¶ˆæ¯å¹¿æ’­ç»™æ‰€æœ‰ç”¨æˆ·ï¼ŒæœåŠ¡å™¨åªèµ·åˆ°ä¸­ç»§ä½œç”¨ã€‚

â€‹	ä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„æ˜¯ï¼ŒIRC çš„èŠå¤©æœåŠ¡é€šå¸¸æœ‰â€œé¢‘é“â€é¢‘é“åç§°ä»¥ # ç¬¦å·å¼€å§‹ï¼Œç”¨æˆ·åœ¨ç›¸åŒçš„é¢‘é“æ—¶å¯ä»¥äº’ç›¸äº¤æµã€‚

â€‹	IRC æ˜¯ 1988 å¹´å‡ºç°çš„ï¼Œå³ä½¿åˆ°äº†ç°åœ¨ï¼Œè¿˜æœ‰ä¸€ç¾¤~~æŠ€æœ¯é—è€~~äººåœ¨ä½¿ç”¨è¿™é¡¹æœåŠ¡èŠå¤©äº¤æµï¼Œç„¶è€Œå¦‚ä»Šæœ‰ WebSocket è¿™ç§åè®®äº†ï¼Œæˆ‘è®¤ä¸º WebSocket æ˜¯æ¯” IRC æ›´é€‚åˆåšèŠå¤©å®¤çš„ï¼ŒWebSocket çš„å®æ—¶æ€§å¯ä»¥å®ç°æ›´å¤šä¸œè¥¿ã€‚

## åœ¨ Rust é‡Œä½¿ç”¨ WebSocket

â€‹	ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ `warp` æä¾›çš„ web æœåŠ¡å™¨æ¡†æ¶å’Œ `tokio` çš„å¼‚æ­¥è¿è¡Œæ¡†æ¶

â€‹	åœ¨ `Cargo.toml` é‡Œæ·»åŠ ä¾èµ–ï¼š

```toml
[dependencies]
warp = "0.3"
tokio = { version = "1", features = ["full"] }
```

â€‹	å»ºç«‹ WebSocket è¿‡æ»¤å™¨ï¼š

```rust
async fn main() {
    let rooms: Rooms = Arc::new(Mutex::new(HashMap::new()));
    let chat = warp::path("chat")
        .and(warp::ws())
        .map(move |ws: warp::ws::Ws| {
            let rooms = rooms.clone();
            ws.on_upgrade(move |socket| handle_init(socket, rooms))
        });
    warp::serve(chat).run(([127, 0, 0, 1], 3030)).await;
}
```

â€‹	`warp::path("chat").and(warp::ws())`  æ˜¯åˆ›å»ºäº†ä¸€ä¸ªè¿‡æ»¤å™¨ï¼ŒåªåŒ¹é…è·¯å¾„ä¸º "/chat" ä¸”è¯·æ±‚å‡çº§åˆ° WebSocket çš„ HTTP è¯·æ±‚ã€‚`warp::serve(chat).run(([127, 0, 0, 1], 3030)).await;` ä½¿ç”¨ `chat` è¿‡æ»¤å™¨åˆ›å»ºä¸€ä¸ª Warp æœåŠ¡å™¨ï¼Œå¯åŠ¨å¹¶ç›‘å¬ `127.0.0.1:3030`

```rust
	let (user_ws_tx, mut user_ws_rx) = ws.split(); // å°† ws: WebSocket åˆ†è§£ä¸ºå‘é€å’Œæ¥æ”¶ä¸¤éƒ¨åˆ†
	// æ¥æ”¶æ¶ˆæ¯
    let msg = user_ws_rx	
        .next()
        .await
        .unwrap()
        .unwrap()
        .to_str()
        .unwrap()
        .to_string();
```

`SplitStream<WebSocket>` â†’ `Next<SplitStream<WebSocket>>` â†’ `Option<Result<Message, Error>>` â†’ `Result<Message, Error>` â†’ `Message` â†’ `Result<&str, ()>` â†’ `&str` â†’ `String`

â€‹	æ³¨æ„è¿™é‡Œçš„ `Message` æ˜¯ `warp` è‡ªå·±çš„ç»“æ„ä½“ï¼Œä¸æ˜¯æˆ‘è‡ªå·±å®šä¹‰çš„ï¼š

```rust
#[derive(Eq, PartialEq, Clone)]
pub struct Message {
    inner: protocol::Message,
}
```

â€‹	å‘é€æ¶ˆæ¯å¦‚ä¸‹ï¼š

```rust
let message = ...;	// String
let ws_msg = warp::ws::Message::text(message);	// Message
user_ws_tx.send(ws_msg).await.unwarp();
```

## åç«¯éƒ¨åˆ†ğŸ¦€

â€‹	é¦–å…ˆå…ˆä»‹ç»ä¸€ä¸‹ `unbounded_channel()` ï¼Œå®ƒæ˜¯ `tokio` åº“é‡Œçš„ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°åˆ›å»ºä¸€ä¸ª unbounded çš„mpsc channelã€‚

> mpscï¼ˆMulti-producer, Single-consumerï¼‰
>
> bounded channel: `mpsc::channel()` ï¼Œéœ€è¦æŒ‡å®šé€šé“å®¹é‡é™åˆ¶
>
> unbounded channelï¼šé€šé“æ— é™å­˜æ”¾æ¶ˆæ¯ç›´åˆ°å†…å­˜è€—å°½ï¼ŒSender å¯ä»¥æ— éœ€ç­‰å¾…åœ°ä¸æ–­å‘é€šé“å‘é€æ¶ˆæ¯ã€‚éœ€è¦ä¿è¯å†…å­˜ä¸ä¼šè€—å°½ã€‚

â€‹	 `unbounded_channel()`  è¿”å›ä¸€ä¸ªå‘é€å™¨ Sender å’Œä¸€ä¸ªæ¥æ”¶å™¨ Receiverï¼Œå…¶ä¸­ Sender å¯è¢«å¤šä¸ªçº¿ç¨‹å…±äº«ï¼Œå®ç°äº† `Clone` ç‰¹å¾ï¼ŒReceiver åˆ™ä¸èƒ½ã€‚ä½¿ç”¨ Sender çš„ `send` æ–¹æ³•å‘é€æ¶ˆæ¯ï¼ŒReceiver çš„ `recv` æ–¹æ³•æ¥æ”¶æ¶ˆæ¯ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•éƒ½æ˜¯å¼‚æ­¥çš„ã€‚

â€‹	æˆ‘çš„æƒ³æ³•æ˜¯ï¼šå¯¹äºæ¯ä¸€ä¸ª WebSocket è¿æ¥ `ws`ï¼Œéƒ½ä¸ºå…¶åˆ›å»ºä¸€ä¸ª `unbounded_channel()`ï¼š`tx` å’Œ `rx`ã€‚ç”¨ä¸€ä¸ª HashMap æ¥å­˜ `<String, tx>`ã€‚å½“è¯¥ `ws` æ¥æ”¶åˆ°æ¶ˆæ¯æ—¶ï¼Œä½¿ç”¨ HashMap é‡Œçš„æ‰€æœ‰ `tx` æ¥å‘é€æ¶ˆæ¯åˆ°å¯¹åº”çš„ `rx`ã€‚ç»™ `rx` ä¸€ä¸ªå¼‚æ­¥å¤„ç†éƒ¨åˆ†ï¼Œå½“ `rx` æ¥æ”¶åˆ°æ¶ˆæ¯æ—¶ï¼Œä½¿ç”¨ `rx` å¯¹åº”çš„ `ws` å‘å®¢æˆ·ç«¯å‘ç°æ¶ˆæ¯ã€‚

â€‹	ä½¿ç”¨ `unbounded_channel()` ä½œä¸ºä¸­é—´äººï¼Œå¯ä»¥è®©å¤šä¸ªæ¶ˆæ¯å­˜åœ¨æ¶ˆæ¯é“¾è¡¨é‡Œä¾æ¬¡å¤„ç†ã€‚æ¶ˆæ¯å¯ä»¥ä¸€å£æ°”å…¨å‘åˆ° `rx` é‡Œï¼Œç„¶å `rx` ä¸€ä¸ªä¸ªå‘é€åˆ°å¯¹åº”çš„ `ws`ã€‚

â€‹	é¢‘é“çš„å®ç°å°±æ˜¯åœ¨å‰é¢ HashMap å¤–é¢å†å¥—ä¸€ä¸ª HashMapï¼Œå‘é€æ¶ˆæ¯æ—¶å¯¹é¢‘é“åç§°è¿›è¡Œåˆ¤æ–­ã€‚

***

å®šä¹‰ç»“æ„ä½“å’Œç±»å‹ï¼š

```rust
struct MessageData {
    username: String,
    content: String,
}
type Users =
    Arc<Mutex<HashMap<String, tokio::sync::mpsc::UnboundedSender<Result<Message, warp::Error>>>>>;
type Rooms = Arc<Mutex<HashMap<String, Users>>>;
```

å»ºç«‹ WebSocket è¿‡æ»¤å™¨å¹¶è¿è¡ŒæœåŠ¡å™¨ï¼š

```rust
    let chat = warp::path("chat")
        .and(warp::ws())
        .map(move |ws: warp::ws::Ws| {
            let rooms = rooms.clone();
            //let users = users.clone();
            ws.on_upgrade(move |socket| handle_init(socket, rooms))
        });
    warp::serve(chat).run(([127, 0, 0, 1], 3030)).await;
```

å½“æœ‰ WebSocket è¿æ¥æ—¶ï¼Œè½¬åˆ°å¤„ç†å‡½æ•° `handle_init`ï¼š

```rust
async fn handle_init(ws: WebSocket, rooms: Rooms) {
    let (user_ws_tx, mut user_ws_rx) = ws.split();	//åˆ†è§£ WebSocket ä¸º Sender å’Œ Receiver
    let (tx, rx) = tokio::sync::mpsc::unbounded_channel();	//å»ºç«‹ä¸€ä¸ª unbounded_channel
    let msg = user_ws_rx	//ç›´æ¥å°è¯•è·å¾—æ¶ˆæ¯ï¼Œè§„å®šè¿æ¥æ—¶çš„ç¬¬ä¸€ä¸ªæ¶ˆæ¯ä¸º{room_id, username}
        .next()
        .await
        .unwrap()
        .unwrap()
        .to_str()
        .unwrap()
        .to_string();

    let v: Value = serde_json::from_str(&msg).unwrap();	// msg å¤„ç†æˆ json
    let room_id = v["room_id"].as_str().unwrap().to_string();	//å–å¾— room_id
    let username = v["username"].as_str().unwrap().to_string();	//å–å¾— username
    //åˆ¤æ–­æ˜¯å¦å­˜åœ¨ roomï¼Œæœ‰åˆ™æ’å…¥è¿™ä¸ª userï¼Œå¦åˆ™åˆ›å»º room 
    if rooms.lock().unwrap().contains_key(&room_id) {	
        rooms
            .lock()
            .unwrap()
            .get(&room_id)
            .unwrap()
            .lock()
            .unwrap()
            .insert(username.clone(), tx.clone());
    } else {
        let users = Arc::new(Mutex::new(HashMap::new()));
        users.lock().unwrap().insert(username.clone(), tx.clone());
        rooms.lock().unwrap().insert(room_id.clone(), users);
    }
    //è½¬åˆ° handle_connection
    handle_connection(username, room_id, user_ws_tx, user_ws_rx, rooms.clone(), rx).await;
}
```

`handle_connection`

```rust
async fn handle_connection(
    user_id: String,
    room_id: String,
    mut user_ws_tx: SplitSink<WebSocket, Message>,
    mut user_ws_rx: SplitStream<WebSocket>,
    rooms: Rooms,
    mut rx: tokio::sync::mpsc::UnboundedReceiver<Result<Message, warp::Error>>,
) {
    //ä¸º rx åˆ›å»ºå¼‚æ­¥ä»»åŠ¡ï¼Œæ”¶åˆ°æ¶ˆæ¯æ—¶ç”¨ user_ws_tx å‘é€æ¶ˆæ¯
    tokio::task::spawn(async move {
        while let Some(result) = rx.recv().await {
            let message = match result {
                Ok(msg) => msg.to_str().unwrap().to_string(),
                Err(e) => {
                    eprintln!("error {}", e);
                    break;
                }
            };
            let ws_msg = warp::ws::Message::text(message);
            user_ws_tx.send(ws_msg).await.unwrap();
        }
    });
	
    //user_ws_rx æ¥æ”¶æ¶ˆæ¯æ—¶ï¼Œç”¨å¯¹åº” room é‡Œçš„æ¯ä¸€ä¸ª tx å‘é€æ¶ˆæ¯ï¼Œå¯¹åº”çš„ rx ä¼šæ¥å—åˆ°ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢é‚£éƒ¨åˆ†
    while let Some(result) = user_ws_rx.next().await {
        match result {
            Ok(msg) => {
                let v: Value = serde_json::from_str(&msg.to_str().unwrap()).unwrap();
                let room_id = v["room_id"].as_str().unwrap().to_string();
                if rooms.lock().unwrap().contains_key(&room_id) {
                    for (roomname, users) in rooms.lock().unwrap().iter() {
                        if roomname != &room_id {
                            continue;
                        }
                        for (_, user) in users.lock().unwrap().iter() {
                            user.send(Ok(msg.clone())).unwrap();
                        }
                    }
                }
            }
            Err(e) => {
                eprintln!("websocket error(uid={}): {}", user_id, e);
                break;
            }
        }
    }
    // remove user from users
    rooms
        .lock()
        .unwrap()
        .get(&room_id)
        .unwrap()
        .lock()
        .unwrap()
        .remove(&user_id);
    // if users is empty, remove room
    if rooms
        .lock()
        .unwrap()
        .get(&room_id)
        .unwrap()
        .lock()
        .unwrap()
        .is_empty()
    {
        rooms.lock().unwrap().remove(&room_id);
    }
}
```

## å‰ç«¯éƒ¨åˆ†

ä½¿ç”¨ React+Viteï¼Œå¹¶æ²¡æœ‰ä½¿ç”¨ä»€ä¹ˆ UI åº“ï¼Œæˆ‘ç”šè‡³è€ƒè™‘æŠŠæ¡†æ¶ä¹Ÿæ‰”äº†ï¼ŒåŸç”Ÿæ‰æ˜¯å¥½ğŸ˜¤

æ³¨æ„ WebSocket è¦ç”¨ `useRef`ï¼Œä¸ç„¶ç»„ä»¶é‡æ–°æ¸²æŸ“æ—¶ä¼šé‡ç½®è¿æ¥ã€‚

```tsx
const Room = () => {
  const { name: roomName } = useParams();
  const [username, setUsername] = useState<string | null>();
  const [messages, setMessages] = useState<
    { username: string; content: string }[]
  >([]);
  const wsRef = useRef<WebSocket | null>(null);
  //Get room name
  if (roomName === undefined) return null;
  let name = roomName;
  if (name[0] === ">") {
    name = name.slice(1);
  } else return null;

  //Get username
  useEffect(() => {
    const username_tmp = window.prompt("Please enter your username");
    setUsername(username_tmp);
  }, []);

  //Connect to WebSocket
  useEffect(() => {
    wsRef.current = new WebSocket("ws://localhost:3030/chat");
    wsRef.current.onopen = () => {
      console.log("connected");
      const message = {
        room_id: roomName,
        username: username,
      };
      wsRef.current?.send(JSON.stringify(message));
    };
    wsRef.current.onmessage = (e) => {
      const newMessage = JSON.parse(e.data);
      setMessages((oldMessages) => [...oldMessages, newMessage]);
    };
  }, [username]);

  //Send message
  const sendMessage = () => {
    const input = document.getElementById("message") as HTMLInputElement;
    const content = input.value;
    if (content === "") return;
    const message = {
      room_id: roomName,
      username: username,
      content: content,
    };
    wsRef.current?.send(JSON.stringify(message));
    input.value = "";
  };

  return (
    <div className="room">
      <h2>Room: {name}</h2>
      <div className="partingLine"></div>
      <div style={{ display: "flex", justifyContent: "center" }}>
        <div className="roomBox">
          {messages.map((message, index) => (
            <MessageBox
              key={index}
              username={message.username}
              content={message.content}
            />
          ))}
        </div>
      </div>
      <div className="input">
        <textarea
          id="message"
          onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              sendMessage();
            }
          }}
        />
        <button onClick={sendMessage}>Send</button>
      </div>
    </div>
  );
};
```



## TODO

- [ ] å¼‚å¸¸é”™è¯¯å¤„ç†
- [ ] `tokio` ä¼¼ä¹æœ‰ `broadcast` è¿™ç§ä¸œè¥¿ï¼Œä¸çŸ¥èƒ½ä¸èƒ½ç”¨
- [ ] æ¢åŸç”Ÿå‰ç«¯
- [ ] ä¸€äº›å¯èƒ½çš„ç»†èŠ‚ä¼˜åŒ–
