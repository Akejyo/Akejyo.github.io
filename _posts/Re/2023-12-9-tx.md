---
title: TXÂ·IEGèè‹±ç­3æœŸä½œä¸šwp
date: 2023-12-9
categories: [Study, Re]
tags: [MISC, Re]
math: true
image:
  path: /img/tx_fen.png
  alt: ~~~
---



# TXÂ·IEGèè‹±ç­3æœŸä½œä¸šwp

## ç¬¬ä¸€æ¬¡ä½œä¸š

ç»™äº†ä¸€ä¸ª `crackme.exe`ï¼Œè¿è¡Œå‡ºç°ä¸€ä¸ªå‘½ä»¤è¡Œç•Œé¢ï¼š

![image-20231209021740185](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209021740185.png)

**é¢˜ç›®è¦æ±‚ï¼š**

1. ä½¿ç”¨Windows API `CreateRemoteThread` è¿œç¨‹æ³¨å…¥æ¨¡å—åˆ° crackme è¿›ç¨‹ä¸­å¹¶ä¸”ä¸å´©æºƒï¼Œç„¶åä½¿ç”¨ ark å·¥å…·(ä¾‹å¦‚ processhacker ç­‰)èƒ½å¤ŸæŸ¥çœ‹æ³¨å…¥æ¨¡å—çš„ä¿¡æ¯ï¼›
2. åˆ†æå¹¶è°ƒè¯•ç¨‹åºï¼Œæ‰¾åˆ°æ­£ç¡®çš„flagï¼›
3. åˆ©ç”¨æ³¨å…¥çš„DLL ï¼ŒHookç¨‹åºä»£ç ï¼šé€šè¿‡Hookè¿›ç¨‹ä¸­çš„å‡½æ•°ä½¿å¾—è¾“å…¥ä»»ä½•å­—ç¬¦ä¸²ï¼Œæ§åˆ¶å°éƒ½ä¼šæ‰“å°â€œæ­£ç¡®â€.

***

### 1. CreateRemoteThread è¿œç¨‹æ³¨å…¥

é¦–å…ˆè¦æ‰¾åˆ°è¿›ç¨‹ pidï¼Œå¯ä»¥é€šè¿‡è¿›ç¨‹åç§°æ‰¾åˆ°å…¶ pid

å…ˆå–ä¸€ä¸ªè¿›ç¨‹å¿«ç…§ï¼Œç„¶åå¾ªç¯éå†æ‰¾è¿›ç¨‹ï¼Œè·å¾—å…¶ pid

```cpp
bool FindProcess(const wchar_t* processName, DWORD& dwProcess) {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // è·å¾—è¿›ç¨‹å¿«ç…§
    if (hProcessSnap == INVALID_HANDLE_VALUE) return false;         // æ£€æŸ¥æ˜¯å¦æœ‰æ•ˆ

    pe32.dwSize = sizeof(PROCESSENTRY32);       // åˆå§‹åŒ–å¤§å°
    if (!Process32First(hProcessSnap, &pe32)) { // è·å–hProcessSnapçš„ç¬¬ä¸€ä¸ªè¿›ç¨‹
        CloseHandle(hProcessSnap);
        return false;
    }
    do {                                                // å¾ªç¯éå†æ‰€æœ‰å¿«ç…§
        if (wcscmp(pe32.szExeFile, processName) == 0) { // åç§°ä¸€è‡´
            dwProcess = pe32.th32ProcessID;
            CloseHandle(hProcessSnap);
            return true;
        }
    } while (Process32Next(hProcessSnap, &pe32));
    CloseHandle(hProcessSnap);
    return false;
}
```

æ³¨å…¥ä¸»ä½“éƒ¨åˆ†ï¼š

1. æ‰“å¼€è¿›ç¨‹å¯¹è±¡ `HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcess);`

   OpenProcess å‡½æ•°ç”¨æ¥æ‰“å¼€ä¸€ä¸ªå·²å­˜åœ¨çš„è¿›ç¨‹å¯¹è±¡ï¼Œè¿”å›è¿›ç¨‹çš„å¥æŸ„ [OpenProcess function ](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)

2. `LPVOID allocatedMem = VirtualAllocEx(hProcess, NULL, sizeof(myDLL), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); ` åœ¨ç›®æ ‡è¿›ç¨‹ä¸­åˆ†é…å†…å­˜å­˜å‚¨DLLçš„è·¯å¾„ï¼Œå•çº¯å°±æ˜¯åˆ†é…ä¸€ä¸ªè·¯å¾„çš„å¤§å°çš„ç©ºé—´ï¼Œè¿”å›å·²åˆ†é…é¡µåŒºåŸŸçš„åŸºå€  [VirtualAllocEx function](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)

3. `WriteProcessMemory(hProcess, allocatedMem, myDLL, sizeof(myDLL), NULL)` å‘è¿›ç¨‹å†™å…¥DLLè·¯å¾„ [WriteProcessMemory function](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)

4. è¿›ç¨‹æ³¨å…¥æœ€æ ¸å¿ƒçš„éƒ¨åˆ†å°±æ˜¯ç”¨ Windows APIï¼Œåœ¨ç›®æ ‡è¿›ç¨‹ä¸Šå¼€ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ LoadLibrary å‡½æ•°åŠ è½½æˆ‘ä»¬è‡ªå·±çš„dllã€‚kernel32.dllæ˜¯ä¸€ä¸ª Windows çš„æ ¸å¿ƒåŠ¨æ€é“¾æ¥åº“æ–‡ä»¶ï¼Œæä¾›å¤§é‡ Windows APIï¼Œæ˜¯ Windows å¿…æœ‰çš„åŠ¨æ€åº“æ–‡ä»¶ï¼Œå¤§å¤šæ•°è¿›ç¨‹éƒ½ä¼šè°ƒç”¨ kernel32.dllï¼Œå…ˆ `GetModuleHandle(TEXT("kernel32.dll"))` è·å¾—ä¸€ä¸‹å¥æŸ„ï¼Œç„¶åæ‰¾åˆ° LoadLibrary çš„é¦–åœ°å€ï¼š

   `FARPROC pLoadLibraryA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");`

   æœ€åä½¿ç”¨ [CreateRemoteThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread) å‡½æ•°å¼€ä¸€ä¸ªçº¿ç¨‹ï¼š

   `HANDLE hThread = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, allocatedMem, 0, 0);`

å®Œæ•´ä¸»å‡½æ•°ä»£ç å¦‚ä¸‹ï¼Œè¿˜åŒ…å«äº†ææƒçš„éƒ¨åˆ†ï¼š

```cpp
#include <bits/stdc++.h>
#include <windows.h>
#include <TlHelp32.h>
#include <tchar.h>

using namespace std;

bool FindProcess(const wchar_t* processName, DWORD& dwProcess) {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // è·å¾—è¿›ç¨‹å¿«ç…§
    if (hProcessSnap == INVALID_HANDLE_VALUE) return false;         // æ£€æŸ¥æ˜¯å¦æœ‰æ•ˆ

    pe32.dwSize = sizeof(PROCESSENTRY32);       // åˆå§‹åŒ–å¤§å°
    if (!Process32First(hProcessSnap, &pe32)) { // è·å–hProcessSnapçš„ç¬¬ä¸€ä¸ªè¿›ç¨‹
        CloseHandle(hProcessSnap);
        return false;
    }
    do {                                                // å¾ªç¯éå†æ‰€æœ‰å¿«ç…§
        if (wcscmp(pe32.szExeFile, processName) == 0) { // åç§°ä¸€è‡´
            dwProcess = pe32.th32ProcessID;
            CloseHandle(hProcessSnap);
            return true;
        }
    } while (Process32Next(hProcessSnap, &pe32));
    CloseHandle(hProcessSnap);
    return false;
}

bool EnableDebugPrivilege() { // ææƒ
    HANDLE token;
    TOKEN_PRIVILEGES tp;
    // æ‰“å¼€è¿›ç¨‹ä»¤ç‰Œç¯
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token)) {
        cout << "æ‰“å¼€è¿›ç¨‹ä»¤ç‰Œå¤±è´¥" << endl;
        return false;
    }
    //  è·å–è¿›ç¨‹æœ¬åœ°å”¯ä¸€ID
    LUID luid;
    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {
        cout << "è·å–LUIDå¤±è´¥" << endl;
        return false;
    }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    tp.Privileges[0].Luid = luid;
    // è°ƒæ•´è¿›ç¨‹æƒé™
    if (!AdjustTokenPrivileges(token, 0, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
        cout << "ææƒå¤±è´¥" << endl;
        return false;
    }
    return true;
}

void CreateRemoteThread_inject() {
    DWORD dwProcess;
    char myDLL[] = "E:\\vs\\test\\x64\\Debug\\test.dll";
    if (FindProcess(L"crackme.exe", dwProcess)) {
        cout << dwProcess << endl;

        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcess);
        LPVOID allocatedMem = VirtualAllocEx(hProcess, NULL, sizeof(myDLL), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); // åœ¨ç›®æ ‡è¿›ç¨‹ä¸­åˆ†é…å†…å­˜å­˜å‚¨DLLçš„è·¯å¾„
        if (!WriteProcessMemory(hProcess, allocatedMem, myDLL, sizeof(myDLL), NULL)) {
            cout << "å†™å…¥DLLè·¯å¾„å¤±è´¥" << endl;
            cout << GetLastError() << endl;
        };
        FARPROC pLoadLibraryA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
        HANDLE hThread = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, allocatedMem, 0, 0);
        if (!hThread) {
            cout << "åˆ›å»ºçº¿ç¨‹å¤±è´¥" << endl;
            cout << GetLastError() << endl;
        };
        CloseHandle(hThread);
        CloseHandle(hProcess);
    }
}
int main() {
    if (!EnableDebugPrivilege()) {
        cout << "ææƒå¤±è´¥" << endl;
        return 0;
    }
    CreateRemoteThread_inject();
    int tmp;
    cin >> tmp;
    return 0;
}
```

æ¥ä¸‹æ¥æ˜¯æˆ‘ä»¬è¦æ³¨å…¥çš„ dllï¼Œdll å·¥ç¨‹å¦‚ä½•å»ºç«‹å¯ç®€å•æœç´¢åˆ°ï¼Œä¸‹é¢çš„ dllmain.cpp å°±æ˜¯ç”¨æ¥ç”Ÿæˆ dll çš„

dllmain.cppä»£ç 

```cpp
// dllmain.cpp : å®šä¹‰ DLL åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚
#include "pch.h"
DWORD WINAPI ThreadProc(){
    MessageBox(NULL, L"æ³¨å…¥æˆåŠŸ", L"1", 0);
    return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, NULL, 0, NULL);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸»å‡½æ•°ç”Ÿæˆçš„ exe å’Œ `dllmain.cpp` ç”Ÿæˆ dll éƒ½å¿…é¡»å’Œ `crackme.exe ` çš„å¹³å°ä¿æŒä¸€è‡´ï¼Œå³éƒ½æ˜¯64ä½ã€‚æ¯”è¾ƒå‘çš„æ˜¯ vs é»˜è®¤æ˜¯ 32ä½ï¼Œè¢«è¿™ä¸ªå‘äº†å·¨ä¹…ã€‚

å…ˆè¿è¡Œ `crackme.exe` ç„¶åè¿è¡Œä¸»å‡½æ•°çš„ç¨‹åºï¼Œç»“æœå¦‚ä¸‹ï¼š

![image-20231209022427403](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209022427403.png)

æˆåŠŸæ‰¾åˆ° crackme è¿›ç¨‹ï¼ˆpid 29344ï¼‰ï¼Œå¹¶å‘ crackme è¿›ç¨‹æ³¨å…¥äº† `test.dll`ï¼Œæ˜¾ç¤ºäº†ä¸€ä¸ªæ¶ˆæ¯æ¡†

***

### 2. æ‰¾åˆ°æ­£ç¡®çš„ flag

ida æ‰“å¼€ï¼Œå­—ç¬¦ä¸²å•¥çš„éƒ½æœäº†ä¸€æ³¢ï¼Œå•¥ä¹Ÿæ²¡å‘ç°.

è¿›å…¥ `main` å‡½æ•°ï¼Œé‡Œé¢å°±ä¸€ä¸ªå‡½æ•° `sub_1400014D0`ï¼Œå†è¿›å»çœ‹çœ‹ï¼Œä¸€æ³¢æ–­ç‚¹è°ƒè¯•åå‘ç°äº†è¾“å‡ºè¾“å…¥å‡½æ•°æ˜¯ä»€ä¹ˆ

```c
  sub_140001020(&v34);
  CreateThread(0i64, 0i64, StartAddress, 0i64, 0, 0i64);
  sub_140001070(&unk_140025600, v37);
```

å…¶ä¸­ `sub_140001020` æ˜¯è¾“å‡ºå‡½æ•°ï¼Œè¿™é‡Œæ˜¯æ‰“å°"è¯·è¾“å…¥flagï¼š"

![image-20231209023325240](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209023325240.png)

ç„¶å `sub_140001070` æ˜¯è¾“å…¥å‡½æ•°ï¼Œè¾“å…¥çš„å­—ç¬¦ä¸²ä¿å­˜åˆ°v37

æ—¢ç„¶çŸ¥é“è¾“å‡ºè¾“å…¥äº†å°±å®¹æ˜“è¯»ä»£ç äº†ï¼Œå†å¾€ä¸‹æ‰¾è¾“å‡ºå‡½æ•°

```cpp
  v31 = v37;
  do
  {
    v32 = (unsigned __int8)*(v31 - 48);
    v33 = (unsigned __int8)*v31 - v32;
    if ( v33 )
      break;
    ++v31;
  }
  while ( v32 );
  if ( v33 )
    v34.m128i_i32[0] = -872817740;
  else
    v34.m128i_i32[0] = -1879061547;
  v34.m128i_i16[2] = 3338;
  *(__int16 *)((char *)v34.m128i_i16 + 1) ^= 0x3736u;
  v34.m128i_i8[3] ^= 0x38u;
  v34.m128i_i8[6] = 0;
  sub_7FF7891B1020(&v34);
```

v37 æ˜¯åˆšæ‰è¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œè¿™é‡Œèµ‹å€¼ç»™äº† v31.

ç„¶åä¸€é¡¿å¾ªç¯ï¼Œç”¨ v33 ä½œåˆ†æ”¯æ¡ä»¶ï¼Œæ–­ç‚¹è°ƒè¯•å¯ä»¥çŸ¥é“ -1879061547 å¯¹åº”çš„æ˜¯æ­£ç¡®ï¼Œ -872817740 å¯¹åº”çš„æ˜¯é”™è¯¯ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è¦è®© v33 ä¸º 0.

å†çœ‹çœ‹é‚£ä¸ªå¾ªç¯ï¼Œ48å¾ˆæœ‰è¿·æƒ‘æ€§ï¼ˆ'0'çš„asciiï¼‰ï¼Œä½†ä»”ç»†ä¸€çœ‹ä¼šå‘ç°å®ƒæ˜¯ç›´æ¥ç”¨v31å­—ç¬¦ä¸²æŒ‡é’ˆå»å‡48ï¼Œè¿™ä¸€å‡å²‚ä¸æ˜¯å°±è·‘åˆ°å…¶ä»–å†…å­˜åœ°æ–¹å»äº†ï¼Œæ–­ç‚¹è°ƒè¯•çœ‹çœ‹ï¼š

![image-20231209023800316](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209023800316.png)

è¿™é‡Œasdæ˜¯æˆ‘éšä¾¿è¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œå¾€ä¸Šæ‰¾48ä½ï¼š

![image-20231209023835070](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209023835070.png)

flagï¼š`HiGWDUuXQS6wVHBTp0ERfJe6VqprMqD1`

***

### 3. Hook

ç”±2å¯ä»¥çŸ¥é“è¿™ä¸ªç¨‹åºçš„é€»è¾‘äº†ï¼Œæƒ³è¦ä¸€ç›´è¾“å‡ºæ­£ç¡®ä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥åœ¨é‚£ä¸ª if åˆ†æ”¯åšæ‰‹è„šå°±å¥½ï¼Œæ–­ç‚¹è°ƒè¯•åˆ°é‚£ä¸ªåˆ†æ”¯ï¼š

![image-20231209024146350](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024146350.png)

è¿™é‡Œå…ˆ test äº†ä¸€ä¸‹ï¼Œç„¶å jnz åšåˆ†æ”¯è·³è½¬ï¼Œåˆ° ce çœ‹çœ‹ï¼š

![image-20231209024348777](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024348777.png)

é‚£å°±å¾ˆæ˜æ˜¾äº†ï¼Œç†è®ºä¸Šæˆ‘ç›´æ¥æŠŠ 18e7 å’Œ 18e9 è¿™ä¸¤ä¸ªæ¢ nop å°±è¡Œ

![image-20231209024456266](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024456266.png)

![image-20231209024521183](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231209024521183.png)

ç„¶åå†åˆ©ç”¨åˆšæ‰åœ¨1é‡Œå†™çš„ dll æ³¨å…¥ï¼Œç›´æ¥é‡å†™ä¸€ä¸‹ dllmainï¼š

```cpp
// dllmain.cpp : å®šä¹‰ DLL åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚
#include "pch.h"
#include <windows.h>
#include <bits/stdc++.h>
using namespace std;
void HookJNE(void* pJNE) {
    DWORD oldProtect;
    VirtualProtect(pJNE, 4, PAGE_EXECUTE_READWRITE, &oldProtect); //4ä¸ªnopï¼Œåˆ†é…4
    *(DWORD*)pJNE = 0x90909090; // æ¢å…¥nop nop nop nop
    VirtualProtect(pJNE, 4, oldProtect, &oldProtect);
}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD ul_reason_for_call,
    LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH: {
        HMODULE hCrackMe = GetModuleHandle(TEXT("crackme.exe")); //è·å¾—åŸºåœ°å€
        if (hCrackMe != NULL) {
            HMODULE jneAddress = (HMODULE)((size_t)hCrackMe + 0x18E7);
            HookJNE((void*)jneAddress);
        }
    } break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

ç„¶åå°±å’Œ1ä¸€æ ·å³å¯

***

## ç¬¬äºŒæ¬¡ä½œä¸š

ç»™äº†ä¸€ä¸ª `crackme1.apk`ï¼Œä¸¢åˆ°è™šæ‹Ÿæœºè¿è¡Œæ˜¯ä¸€ä¸ªè¾“å…¥å­—ç¬¦ä¸²çš„ç•Œé¢ï¼Œè¾“å…¥å­—ç¬¦ä¸²ç‚¹å‡»ç¡®è®¤ä¼šå¼¹å‡º toast æ¶ˆæ¯ "wrong" æˆ–è€… "right"

é¢˜ç›®è¦æ±‚ï¼š

1. ä½¿ç”¨ptraceæŠ€æœ¯è¿œç¨‹æ³¨å…¥æ¨¡å—åˆ°crackme1è¿›ç¨‹ä¸­å¹¶ä¸”ä¸å´©æºƒï¼Œç„¶åä½¿ç”¨å¦‚ä¸‹å‘½ä»¤åœ¨è¿œç¨‹è¿›ç¨‹ä¸­èƒ½å¤ŸæŸ¥çœ‹æ³¨å…¥æ¨¡å—çš„ä¿¡æ¯ï¼›
2. é€šè¿‡hookè¿›ç¨‹ä¸­çš„å‡½æ•°ä½¿å¾—è¾“å…¥ä»»ä½•å­—ç¬¦ä¸²ï¼Œç‚¹å‡»ç¡®è®¤éƒ½ä¼šå¼¹å‡ºtoastæ¶ˆæ¯â€rightâ€.

***

é‡åˆ°å¾ˆå¤šç¯å¢ƒä»€ä¹ˆçš„é—®é¢˜ï¼Œæ”¾ç‚¹é“¾æ¥ï¼š

[Android SDK Tools å®‰è£…æ—¶æ‰¾ä¸åˆ°JDK](https://blog.csdn.net/qq_48016058/article/details/113869661#:~:text=ä»Šå¤© å®‰è£…Android studio çš„ æ—¶ å€™å‘ç° å®‰è£… ç¨‹åº,Files Java  jdk 1.7.0_21â€äº†ã€‚ ï¼ˆè¿™ä¸ªåœ°æ–¹ä¸€å®šè¦è®¾ç½® JAVA â€”HOME%2Cä½¿ç”¨ç›´æ¥èµ‹)

[å®‰å“æ¨¡æ‹Ÿå™¨ç®€ä»‹å’Œadbä½¿ç”¨](https://blog.csdn.net/weixin_42311335/article/details/112136351)

æœ€æ–°ç‰ˆçš„Android Studioæ²¡æ³•æ–­ç‚¹è°ƒè¯•æ˜¯å› ä¸ºæ²¡æœ‰smail ideaï¼Œæ‰‹åŠ¨ä¸‹è½½[Android studio æ–­ç‚¹ç°è‰² ](https://blog.51cto.com/u_16213581/7106707#:~:text=ä¹‹å‰æˆ‘å†™è¿‡ä¸€ç¯‡Android Studio 3.0%2Bæ— æºç è°ƒè¯•apkçš„åšå®¢ï¼Œå¯èƒ½å¾ˆå¤šå°ä¼™ä¼´è¯•äº†ï¼Œå‘ç°è™½ç„¶apkæ˜¯å¯¼å…¥è¿›Android Studioï¼Œä½†æ˜¯å´æ— æ³•åŠ æ–­ç‚¹ï¼Œä¸»è¦æ˜¯å› ä¸ºæ–°ç‰ˆæœ¬çš„Android Studioé»˜è®¤è§£æsmaliæ–‡ä»¶çš„æ’ä»¶æ˜¯ Smali Support ï¼Œè¿™ä¸ªæ’ä»¶ä¸æ”¯æŒæ–­ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è‡ªå·±æ‰‹åŠ¨ä¸‹è½½æ”¯æŒæ–­ç‚¹çš„smaliè§£ææ’ä»¶ï¼š,1ã€ä¸‹è½½æ”¯æŒæ–­ç‚¹çš„smaliè§£ææ’ä»¶ï¼š smalidea%2Cç›®å‰æœ€æ–°çš„ç‰ˆæœ¬æ˜¯ 0.0.6 ï¼Œä»–ä»¬GitHubä»“åº“æºç åœ¨ è¿™é‡Œ ï¼Œæœ‰å…´è¶£çš„å¯ä»¥å»ç…ä¸€ç…ï¼Œæ³¨æ„ï¼šAndroid Studio 4.1.%2Bçš„ä¸€å®šè¦ç”¨0.0.6ç‰ˆæœ¬ä»¥ä¸Šçš„ï¼Œå¦åˆ™æ²¡æ•ˆæœ)

***

### 1. petrace è¿œç¨‹æ³¨å…¥

**ptraceæ­¥éª¤ï¼š**

1. è°ƒç”¨ ptrace ç³»ç»Ÿå‡½æ•°è¿›è¡Œé™„åŠ åˆ°è¿œç¨‹è¿›ç¨‹
2. ä¿å­˜å¯„å­˜å™¨çš„ç¯å¢ƒæ•°æ®
3. è°ƒç”¨ malloc ç³»ç»Ÿå‡½æ•°è¿›è¡Œåˆ†é…å†…å­˜ç©ºé—´
4. æƒ³é™„åŠ çš„è¿›ç¨‹å†™å…¥æ¨¡å—åç§°å’Œè¦æ‰§è¡Œçš„å‡½æ•°åç§°
5. è°ƒç”¨ dlopen ç³»ç»Ÿå‡½æ•°è¿›è¡Œæ‰“å¼€æ³¨å…¥çš„æ¨¡å—
6. æ¢å¤å¯„å­˜å™¨çš„ç¯å¢ƒæ•°æ®
7. è°ƒç”¨ ptrace ç³»ç»Ÿå‡½æ•°è¿›è¡Œå’Œé™„åŠ è¿›ç¨‹è¿›è¡Œå‰¥ç¦»

`malloc` å’Œ `dlopen` åˆ†åˆ«åœ¨ `libc.so` å’Œ `libdl.so` ä¸­ï¼Œ32ä½ Android è®¾å¤‡ä¸Šä¸€èˆ¬ ä½äº`/system/lib`

```shell
:/ # ls /system/lib | grep libc.so
libc.so
:/ # ls /system/lib | grep libdl.so                                        
libdl.so
```

***

1. **é™„åŠ è¿›ç¨‹ã€è„±ç¦»è¿›ç¨‹ã€æ¢å¤è¿›ç¨‹ã€è¯»å†™å¯„å­˜å™¨**

è°ƒç”¨ `ptrace` å‡½æ•°ï¼Œå‚æ•°ä½¿ç”¨ `PTRACE_ATTACH`ã€`PTRACE_DETACH`ã€`PTRACE_CONT`ã€`PTRACE_GETREGS`ã€`PTRACE_SETREGS`ï¼Œä¸‹é¢æ˜¯é™„åŠ è¿›ç¨‹å’Œè¯»å¯„å­˜å™¨çš„ä»£ç ï¼š

```c
// é™„åŠ è¿›ç¨‹
void ptrace_attach(pid_t pid) {
    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {
        printf("Failed to attach:%d\n", pid);
        return;
    };
    waitpid(pid, NULL, 0);
}
// è¯»å¯„å­˜å™¨
void ptrace_getRegs(pid_t pid, struct pt_regs *regs_addr) {
    if (ptrace(PTRACE_GETREGS, pid, NULL, (void *)regs_addr) == -1) {
        printf("Failed to get regs:%d\n", pid);
        return;
    };
}
```

2. **è¯»å–ã€å†™å…¥æ•°æ®**

ä¸‹é¢æ˜¯è¯»å–æ•°æ®çš„ä»£ç ï¼š

```c
void ptrace_readData(pid_t pid, void *addr, size_t len, void *buf) {
    long i, j, remain;
    char *laddr;
    union u {
        long val;
        char chars[sizeof(long)];
    } d;
    j = len / 4;
    remain = len % 4;
    laddr = buf;
    for (i = 0; i < j; i++) {
        d.val = ptrace(PTRACE_PEEKDATA, pid, addr + i * 4, NULL);
        memcpy(laddr, d.chars, 4);
        laddr += 4;
    }
    if (remain) {
        d.val = ptrace(PTRACE_PEEKDATA, pid, addr + i * 4, NULL);
        memcpy(laddr, d.chars, remain);
    }
}
```

è¿™é‡Œä½¿ç”¨äº† union æ¥æ–¹ä¾¿ç±»å‹è½¬æ¢ï¼Œä½¿ç”¨ `ptrace(PTRACE_PEEKDATA, pid, addr + i * 4, NULL);`  è¯»å–æ•°æ®æ—¶ï¼Œä¸€æ¬¡æ˜¯è¯»ä¸€ä¸ª long çš„æ•°æ®ï¼Œæ‰€ä»¥å¤šä½™çš„æ•°æ®è¦ç‰¹æ®Šå¤„ç†ã€‚

å¯¹äºå†™å…¥æ•°æ®ï¼Œå¯¹äºå¤šä½™çš„æ•°æ®è¦å…ˆè¯»ä¸€ä¸ª long çš„åŸæ•°æ®ï¼Œç„¶åä¸€ä¸ªä¸ªèµ‹å€¼è¿›å»å†å†™å…¥ã€‚

3. **è°ƒç”¨ç³»ç»Ÿè¿›ç¨‹å‡½æ•°**

è°ƒç”¨ç³»ç»Ÿè¿›ç¨‹å‡½æ•°é¦–å…ˆéœ€è¦çŸ¥é“è¿›ç¨‹å‡½æ•°çš„å†…å­˜åœ°å€ä»¥åŠè°ƒç”¨è¿™ä¸ªå‡½æ•°éœ€è¦çš„å‚æ•°ï¼Œå…ˆä¿å­˜åŸå§‹å¯„å­˜å™¨ï¼Œè®¾ç½®å¯„å­˜å™¨ï¼Œå°†å‰4ä¸ªå‚æ•°ä¾æ¬¡æ”¾åœ¨ r0-r3 å¯„å­˜å™¨ï¼Œå¤šä½™çš„å‚æ•°æ”¾å…¥æ ˆä¸­ï¼š

```c
	struct pt_regs regs;
	for (int i = 0; i < paramNum && i < 4; i++)
        regs.uregs[i] = param[i];
    if (paramNum > 4) {
        regs.uregs[13] -= (paramNum - 4) * sizeof(long);
        ptrace_writeData(pid, (void *)regs.ARM_sp, (paramNum - 4) * sizeof(long), (void *)&param[4]);
    }
```

å…¶ä¸­ `regs.uregs[13]` æ˜¯ SP å¯„å­˜å™¨æ ˆæŒ‡é’ˆï¼Œæ ˆæŒ‡é’ˆæ˜¯å‘ä¸‹å¢é•¿çš„ï¼Œæ‰€ä»¥å…ˆ -= é¢„ç•™ä½ç½®å†å†™è¿›å»ã€‚

å°† PC å¯„å­˜å™¨ `regs.uregs[15]` ç§»åŠ¨åˆ°ç³»ç»Ÿè¿›ç¨‹å‡½æ•°çš„åœ°å€ã€‚ç”±äº ARM æ¶æ„æœ‰ ARM å’Œ Thumb ä¸¤ç§æŒ‡ä»¤é›†ï¼Œå‰è€…æŒ‡ä»¤ 4 å­—èŠ‚é•¿ï¼Œåè€…æ˜¯ 2 å­—èŠ‚é•¿ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­å…¶æ˜¯ Thumb æ¨¡å¼è¿˜æ˜¯ ARM æ¨¡å¼ã€‚PC æœ€ä½ä½ä¸º 1 åˆ™æ˜¯ Thumb æ¨¡å¼ï¼Œéœ€è¦å°† CPSR å¯„å­˜å™¨çš„ T ä½ç½®1ï¼Œç„¶åæ¸…é™¤ PC å¯„å­˜å™¨æœ€ä½ä½ï¼›åä¹‹æ˜¯ ARM æ¨¡å¼ï¼ŒCPSR çš„ T ä½ç½® 0ã€‚æœ€åå°† LR (`regs.uregs[14]`) ç½®0

```c
    #define CPSR_T_MASK 0x20
	regs.uregs[15] = (long)proc_addr;
    if (regs.uregs[15] & 1) {           // thumbæ¨¡å¼
        regs.uregs[15] &= (~1u);        // pcæ¸…é™¤æœ€ä½ä½ï¼Œä¿æŒä¸ºå¶æ•°
        regs.uregs[16] |= CPSR_T_MASK;  // cpsrçš„Tä½ç½®1
    } else {                            // armæ¨¡å¼
        regs.uregs[16] &= ~CPSR_T_MASK; // cpsrçš„Tä½ç½®0
    }
    regs.uregs[14] = 0;                 // lrç½®0
```

æ¥ç€è®¾ç½®å¯„å­˜å™¨åˆ°è¿›ç¨‹ï¼Œæ¢å¤è¿›ç¨‹ç»§ç»­ï¼Œç­‰å¾…ç»“æŸåæ¢å¤åˆ°åŸæ¥çš„å¯„å­˜å™¨ï¼Œè·å¾—è¿”å›å€¼ R0

4. **è·å–æ¨¡å—åŸºå€**

ä¾æ®æ˜¯è‡ªå·±çš„è¿˜æ˜¯å…¶ä»–çš„è¿›ç¨‹ï¼Œåˆ°ä¸åŒçš„åœ°æ–¹å»æ‰¾ `"/proc/self/maps"` `"/proc/%d/maps", pid`ï¼Œç„¶å `fopen` æ‰“å¼€è¯»å–ï¼ŒåŒ¹å¯¹å­—ç¬¦ä¸²æ‰¾å¯¹åº”çš„åœ°å€.

5. **è·å–ç›®æ ‡è¿›ç¨‹å‡½æ•°çš„å†…å­˜åœ°å€**

å‡½æ•°å‚æ•° `pid`ã€`lib_path`ã€`func_name`ï¼Œå…ˆç”¨ `dlopen` æ‰“å¼€åº“æ–‡ä»¶ï¼Œè·å¾—åº“çš„å¥æŸ„ `handle`ï¼Œç„¶åç”¨ 4 é‡Œçš„å‡½æ•° `get_moduleBase` è·å¾—å½“å‰è¿›ç¨‹ä¸­åº“çš„åŸºåœ°å€ `local_handle` ï¼Œç”¨ `dlsym(handle, func_name)` å‡½æ•°è·å¾—å½“å‰è¿›ç¨‹åº“ä¸­å‡½æ•°çš„åœ°å€ `local_func_addr`ï¼Œè®¡ç®—å‡½æ•°ç›¸å¯¹äºåº“åŸºåœ°å€çš„åç§»é‡ `func_offset = local_func_addr - local_handle;`ï¼Œåˆ©ç”¨è¿™ä¸ªåç§»é‡ï¼Œå†è·å¾—ç›®æ ‡è¿›ç¨‹ä¸­åº“çš„åŸºåœ°å€å°±å¯ä»¥è®¡ç®—å¾—åˆ°ç›®æ ‡è¿›ç¨‹ä¸­å‡½æ•°çš„åœ°å€ã€‚

```c
    handle = dlopen(lib_path, RTLD_LAZY);
    dlerror();
    local_handle = get_moduleBase(-1, lib_path);
    local_func_addr = dlsym(handle, func_name);
    func_offset = local_func_addr - local_handle;
    dlclose(handle);
    remote_handle = get_moduleBase(pid, lib_path);
    remote_func_addr = remote_handle + func_offset;
```

æ›´å…·ä½“çš„è¯´æ˜ï¼Œ`dlopen` å‡½æ•°æ¥å—åº“æ–‡ä»¶çš„è·¯å¾„ï¼Œå°†åº“æ–‡ä»¶åŠ è½½åˆ°å½“å‰è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼Œè¿”å›ä¸€ä¸ªå¥æŸ„ï¼Œè¿™ä¸ªå¥æŸ„å¹¶éåº“æ–‡ä»¶åœ¨å½“å‰åœ°å€ç©ºé—´çš„åŸºåœ°å€ï¼ˆéœ€è¦ç”¨ `get_moduleBase` è·å¾—ï¼‰ï¼Œå¥æŸ„å’ŒåŸºåœ°å€ä¸æ˜¯ä¸€æ¦‚å¿µã€‚

6. **æ³¨å…¥å‡½æ•°**

* `ptrace_attach` é™„åŠ è¿›ç¨‹

* è°ƒç”¨ `malloc` å‡½æ•°åˆ†é…å†…å­˜ï¼Œå†ç”¨ `ptrace_writeData` å†™å…¥ `lib_path`

  ```c
      malloc_addr = get_remoteFuncAddr(pid, "/system/lib/arm/libc.so", "malloc");
      params[0] = strlen(lib_path) + 1;
      mem_addr = ptrace_call(pid, malloc_addr, 1, params);
  	ptrace_writeData(pid, mem_addr, strlen(lib_path) + 1, (void *)lib_path);
  ```

* è°ƒç”¨ `dlopen` å‡½æ•°åŠ è½½ `lib`

  ```c
      dlopen_addr = get_remoteFuncAddr(pid, "/system/lib/arm/linker", "dlopen");
      params[0] = (long)mem_addr;  // filename
      params[1] = (long)RTLD_LAZY; // flags
      ptrace_call(pid, dlopen_addr, 2, params)
  ```

* æ¢å¤è¿›ç¨‹ `ptrace_continue(pid);`ï¼Œè„±ç¦»è¿›ç¨‹ `ptrace_detach(pid);`

7. **åˆ©ç”¨è¿›ç¨‹åè·å¾— `pid`** 

è°ƒç”¨ shell æŒ‡ä»¤ `pidof` å®ç°ã€‚å…ˆå°†æŒ‡ä»¤å†™å…¥å­—ç¬¦ä¸²ï¼Œä½¿ç”¨ `popen` å‡½æ•°æ‰§è¡ŒæŒ‡ä»¤ï¼Œ`fread` å‡½æ•°è¯»å–è¾“å‡º

***

ç¼–è¯‘ `injector.c`ï¼š

é¦–å…ˆå» Android Studio ä¸‹è½½ NDKï¼Œä¹‹åæ·»åŠ ç¯å¢ƒè·¯å¾„ `E:\SDK\platform-tools` å’Œ `E:\SDK\ndk\26.1.10909125\toolchains\llvm\prebuilt\windows-x86_64\bin`ï¼Œç„¶åå°±å¯ä»¥åœ¨å‘½ä»¤è¡Œé‡Œä¹‹é—´ç¼–è¯‘ï¼š`armv7a-linux-androideabi26-clang -o injector injector.c`

ç¼–è¯‘ç”Ÿæˆ .soï¼š`gcc injectso.c -fPIC -shared -o injectso.so`

æˆ‘è‡ªå·±ç”µè„‘ä¸Šç”¨çš„æ˜¯è“å æ¨¡æ‹Ÿå™¨ï¼Œæœ€å¼€å§‹è¿æ¥çš„æ—¶å€™æ²¡è¿ä¸Šï¼Œç„¶å Android Studio å¯¹ arm æ¶æ„çš„é€‚é…æå·®ï¼Œå®Œå…¨æ‰“ä¸å¼€ AVDï¼Œç„¶åä¸‹äº†é›·ç”µæ¨¡æ‹Ÿå™¨ï¼Œè¿™ä¸ªæ¨¡æ‹Ÿå™¨æ˜¯ x86 çš„ï¼Œæˆ‘èŠ±äº†ä¸€ä¸¤å¤©çš„æ—¶é—´å°è¯•å®‰è£… arm å…¼å®¹åº“æœªæœï¼Œæœ€åç¿»åˆ°ä¸€ä¸ªå¸–å­ï¼ˆç”šè‡³æ˜¯NGAçš„ï¼‰[[å›½æœç›¸å…³\]å‘ç°æœ‰ä¸€äº›æ¨¡æ‹Ÿå™¨é»˜è®¤è£…armæ¶æ„çš„](https://ngabbs.com/read.php?tid=33707297&rand=504)ï¼Œè¿™ä¸ªå¸–å­æœ¬æ¥æ˜¯å–·æœ‰äº› arm æ¨¡æ‹Ÿå™¨æ€§èƒ½ä¸å¥½çš„ï¼Œå´ç»™äº†æˆ‘æœç´¢æ–¹å‘ã€‚ç„¶ååˆçœ‹åˆ°ä¸€ä¸ªå¸–å­ä»‹ç»åˆ°è“å èƒ½é€‚é…å„ç§æ¶æ„ï¼Œæˆ‘æ‰“å¼€è“å æ¨¡æ‹Ÿå™¨ä¸€çœ‹ï¼Œx86 32-bit, x86 64-bit, ARM 32-bit, ARA 64-bitï¼Œæœç„¶è¿˜æ˜¯å¾—ä¿¡ä»»è“å ã€‚ä¸€æ³¢æ“ä½œåå¾ˆé¡ºåˆ©çš„è¿è¡Œæ³¨å…¥å™¨ç¨‹åºäº†. åæ¥ç”¨ wsa ä¹ŸæˆåŠŸäº†.

ç„¶åæˆ‘çæ£é¼“äº†æ•´æ•´5å¤©æ¥è§£å†³è·å–å¯„å­˜å™¨æ—¶çš„æŠ¥é”™ï¼š`Device or resource busy`ï¼ŒçœŸæ˜¯ä¸€ç‚¹æ–¹æ¡ˆéƒ½æ‰¾ä¸åˆ°ï¼Œæˆ‘åªèƒ½è®¤ä¸ºæ˜¯æ¨¡æ‹Ÿå™¨çš„é—®é¢˜ğŸ˜¥ï¼Œä»¥åæ•´ä¸ªä¾¿å®œçœŸæœºå†è¯•è¯•å§.

å®Œæ•´ä»£ç ï¼š

```c
#include <dlfcn.h>
#include <link.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <errno.h>
#define CPSR_T_MASK 0x20
// é™„åŠ è¿›ç¨‹
int ptrace_attach(pid_t pid) {
    int status;
    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {
        return -1;
    }
    waitpid(pid, &status, 0);
    printf("attach to process pid: %d\n", pid);
    return 0;
}
// è„±ç¦»è¿›ç¨‹
int ptrace_detach(pid_t pid) {
    if (ptrace(PTRACE_DETACH, pid, NULL, NULL) == -1) {
        printf("Failed to detach:%d, error: %s\n", pid, strerror(errno));
        return -1;
    };
    return 0;
}
// æ¢å¤è¿›ç¨‹è¿è¡Œ
int ptrace_continue(pid_t pid) {
    if (ptrace(PTRACE_CONT, pid, NULL, NULL) == -1) {
        printf("Failed to continue:%d, error: %s\n", pid, strerror(errno));
        return -1;
    };
    return 0;
}
// è¯»å¯„å­˜å™¨
int ptrace_getRegs(pid_t pid, struct user_regs *regs_addr) {
    if (ptrace(PTRACE_GETREGS, pid, NULL, (void *)regs_addr) == -1) {
        printf("Failed to get regs:%d, error: %s\n", pid, strerror(errno));
        return -1;
    }
    return 0;
}
// è®¾ç½®å¯„å­˜å™¨
int ptrace_setRegs(pid_t pid, struct user_regs *regs_addr) {
    if (ptrace(PTRACE_SETREGS, pid, NULL, (void *)regs_addr) == -1) {
        printf("Failed to set regs:%d\n", pid);
        return -1;
    };
    return 0;
}
// è¯»å–æ•°æ®
void ptrace_readData(pid_t pid, void *addr, size_t len, void *buf) {
    long i, j, remain;
    char *laddr;
    union u {
        long val;
        char chars[sizeof(long)];
    } d;
    j = len / 4;
    remain = len % 4;
    laddr = buf;
    for (i = 0; i < j; i++) {
        d.val = ptrace(PTRACE_PEEKDATA, pid, addr + i * 4, NULL);
        memcpy(laddr, d.chars, 4);
        laddr += 4;
    }
    if (remain) {
        d.val = ptrace(PTRACE_PEEKDATA, pid, addr + i * 4, NULL);
        memcpy(laddr, d.chars, remain);
    }
}
// å†™å…¥æ•°æ®
void ptrace_writeData(pid_t pid, void *addr, size_t len, void *buf) {
    long i, j, remain;
    char *laddr;
    union u {
        long val;
        char chars[sizeof(long)];
    } d;
    j = len / 4;
    remain = len % 4;
    laddr = buf;
    for (i = 0; i < j; i++) {
        memcpy(d.chars, laddr, 4);
        ptrace(PTRACE_POKEDATA, pid, addr + i * 4, d.val);
        laddr += 4;
    }
    if (remain) { // å¤šä½™éƒ¨åˆ†å…ˆè¯»åŸæ•°æ®
        d.val = ptrace(PTRACE_PEEKDATA, pid, addr + i * 4, NULL);
        for (j = 0; j < remain; j++)
            d.chars[j] = *laddr++;
        ptrace(PTRACE_POKEDATA, pid, addr + i * 4, d.val);
    }
}

// è°ƒç”¨ç³»ç»Ÿè¿›ç¨‹å‡½æ•°
void *ptrace_call(pid_t pid, void *proc_addr, int paramNum, long *param) {
    int status;
    struct user_regs regs, original_regs;
    long parameters[10];
    // ä¿å­˜åŸå§‹å¯„å­˜å™¨
    ptrace_getRegs(pid, &original_regs);
    memcpy(&regs, &original_regs, sizeof(struct user_regs));
    // SP: uregs[13]
    // LR: uregs[14]
    // PC: uregs[15]
    // CPSR: uregs[16]
    // è®¾ç½®å¯„å­˜å™¨ï¼Œå‰4ä¸ªå‚æ•°æ”¾åœ¨r0-r3ä¸­ï¼Œåé¢çš„å‚æ•°æ”¾å…¥æ ˆä¸­
    for (int i = 0; i < paramNum && i < 4; i++)
        regs.uregs[i] = param[i];
    if (paramNum > 4) {
        regs.uregs[13] -= (paramNum - 4) * sizeof(long);
        ptrace_writeData(pid, (void *)regs.uregs[13], (paramNum - 4) * sizeof(long), (void *)&param[4]);
    }
    regs.uregs[15] = (long)proc_addr;
    if (regs.uregs[15] & 1) {           // thumbæ¨¡å¼
        regs.uregs[15] &= (~1u);        // pcæ¸…é™¤æœ€ä½ä½ï¼Œä¿æŒä¸ºå¶æ•°
        regs.uregs[16] |= CPSR_T_MASK;  // cpsrçš„Tä½ç½®1
    } else {                            // armæ¨¡å¼
        regs.uregs[16] &= ~CPSR_T_MASK; // cpsrçš„Tä½ç½®0
    }
    regs.uregs[14] = 0;                 // lrç½®0

    if (ptrace_setRegs(pid, &regs) != 0 || ptrace_continue(pid) != 0) {
        printf("call proc 0x%lx failed\n", (unsigned long)proc_addr);
        return NULL;
    }
    waitpid(pid, &status, WUNTRACED);

    while (1) {
        if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP) {
            break;
        }
        ptrace_continue(pid);
        waitpid(pid, &status, WUNTRACED);
    }
    ptrace_getRegs(pid, &regs);          // è·å¾—è¿”å›å€¼r0
    ptrace_setRegs(pid, &original_regs); // æ¢å¤åŸå§‹å¯„å­˜å™¨

    return (void *)regs.uregs[0];
}
// è·å–æ¨¡å—åŸºå€
void *get_moduleBase(pid_t pid, const char *moduleName) {
    FILE *fp;
    long addr = 0;
    char *pch;
    char filename[32];
    char line[1024];
    if (pid < 0) {
        // self process
        snprintf(filename, sizeof(filename), "/proc/self/maps");
    } else {
        snprintf(filename, sizeof(filename), "/proc/%d/maps", pid);
    }
    fp = fopen(filename, "rt");
    if (fp != NULL) {
        while (fgets(line, sizeof(line), fp)) {
            if (strstr(line, moduleName)) {
                sscanf(line, "%lx", (unsigned long *)(&addr));
                break;
            }
        }
        fclose(fp);
    }
    return (void *)addr;
}
// è·å–å‡½æ•°å†…å­˜åœ°å€
void *get_remoteFuncAddr(pid_t pid, const char *lib_path, const char *func_name) {
    void *handle, *local_handle, *local_func_addr, *remote_handle, *remote_func_addr;
    unsigned long func_offset;

    if ((handle = dlopen(lib_path, RTLD_LAZY)) == NULL) {
        printf("dlopen failed: %s\n", dlerror());
        return NULL;
    }
    dlerror();
    local_handle = get_moduleBase(-1, lib_path);
    local_func_addr = dlsym(handle, func_name);
    func_offset = local_func_addr - local_handle;
    dlclose(handle);
    remote_handle = get_moduleBase(pid, lib_path);
    remote_func_addr = remote_handle + func_offset;
    printf("remote_func_addr: %p\n", remote_func_addr);
    return remote_func_addr;
}

void inject(pid_t pid, const char *lib_path) {
    void *mem_addr, *malloc_addr, *dlopen_addr;
    long params[10];
    // ATTACH é™„åŠ è¿›ç¨‹

    ptrace_attach(pid);
    malloc_addr = get_remoteFuncAddr(pid, "/system/lib/arm/libc.so", "malloc");
    // è°ƒç”¨mallocå‡½æ•°åˆ†é…å†…å­˜å†™å…¥lib_path "/system/lib/arm/libc.so"
    params[0] = strlen(lib_path) + 1;
    mem_addr = ptrace_call(pid, malloc_addr, 1, params);
    if (mem_addr == NULL) {
        printf("malloc failed in target process, exit\n");
        ptrace_continue(pid);
        ptrace_detach(pid);
        return;
    }
    ptrace_writeData(pid, mem_addr, strlen(lib_path) + 1, (void *)lib_path);

    dlopen_addr = get_remoteFuncAddr(pid, "/system/lib/arm/linker", "dlopen");
    // è°ƒç”¨dlopenå‡½æ•°åŠ è½½lib "/system/lib/arm/libdl.so"  "/system/lib/arm/linker"
    params[0] = (long)mem_addr;  // filename
    params[1] = (long)RTLD_LAZY; // flags
    if (ptrace_call(pid, dlopen_addr, 2, params) == NULL) {
        printf("dlopen failed in target process, exit\n");
        ptrace_continue(pid);
        ptrace_detach(pid);
        return;
    }

    ptrace_continue(pid);
    ptrace_detach(pid);
}
pid_t find_pid(const char *process_name) {
    pid_t process_pid = -1;
    FILE *fp = NULL;
    char cli_cmd[1024];
    char cli_output[1024];
    sprintf(cli_cmd, "pidof %s", process_name);
    fp = popen(cli_cmd, "r");
    fread(cli_output, 1, 1024, fp);
    pclose(fp);
    if (!strlen(cli_output)) {
        printf("process not found: %s\n", process_name);
        return -1;
    }
    sscanf(cli_output, "%d", &process_pid);
    printf("pid of %s: %d\n", process_name, process_pid);
    return process_pid;
}
int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: %s <process_name> <lib_path>\n", argv[0]);
        return 0;
    }
    pid_t pid = find_pid(argv[1]);
    inject(pid, argv[2]);
    return 0;
}

```



### 2. Hook

è™½ç„¶æˆ‘è¿å‰é¢çš„æ³¨å…¥éƒ½æ²¡æˆåŠŸï¼Œè¿˜æ˜¯å­¦ä¹ ä¸€ä¸‹è¿™ä¸ªå§ ğŸ‘‹

Android Studio æ‰“å¼€çœ‹ apk çœ‹ `crackme1/java/com.example/crackme1/MainActivity$1`ï¼Œä½†æ˜¯ smali å±å®éš¾çœ‹ï¼Œjebæ‰“å¼€çœ‹çœ‹ï¼š

```java
public class MainActivity extends AppCompatActivity {
    private ActivityMainBinding binding;
    private Button btn1;

    static {
        System.loadLibrary("crackme1");
    }

    public MainActivity() {
        super();
    }

    protected void onCreate(Bundle arg3) {
        super.onCreate(arg3);
        ActivityMainBinding v0 = ActivityMainBinding.inflate(this.getLayoutInflater());
        this.binding = v0;
        this.setContentView(v0.getRoot());
        View v0_1 = this.findViewById(0x7F080058);
        this.btn1 = ((Button)v0_1);
        ((Button)v0_1).setOnClickListener(new View$OnClickListener() {
            public void onClick(View arg6) {
                Toast.makeText(MainActivity.this, MainActivity.this.stringFromJNI(MainActivity.this.findViewById(0x7F08000E).getText().toString()), 0).show();
            }
        });
    }

    public native String stringFromJNI(String arg1) {
    }
}

```

å°† crackme1.apk åç¼€æ”¹ .zip å†è§£å‹ï¼Œä½¿ç”¨ ida32 æ‰“å¼€é‡Œé¢çš„ libcrackme1.soï¼Œæ‰¾åˆ°å‡½æ•° `Java_com_example_crackme1_MainActivity_stringFromJNI`

```c
int __fastcall Java_com_example_crackme1_MainActivity_stringFromJNI(int a1, int a2, int a3)
{
  char *s2; // [sp+Ch] [bp-7Ch]
  int v6; // [sp+1Ch] [bp-6Ch]
  char s[100]; // [sp+20h] [bp-68h] BYREF

  s2 = (char *)sub_12A4(a1, a3, 0);
  memset(s, 0, sizeof(s));
  qmemcpy(s, "123", 3);
  sub_F50(5, s);
  if ( !strncmp(s, s2, 5u) || (sub_1134() & 1) != 0 )
    v6 = sub_12EC(a1, "right");
  else
    v6 = sub_12EC(a1, "wrong");
  return v6;
}
```

è¿™ä¸ªå‡½æ•°å°† s å’Œ s2 åšæ¯”è¾ƒï¼Œsub_12A4 å‡½æ•°æ¯”è¾ƒç®€ç•¥ï¼Œä¹Ÿè®¸æ˜¯è·å–è¾“å…¥å­—ç¬¦ä¸²ï¼Œçœ‹çœ‹ sub_F50ï¼š

```c
int __fastcall sub_F50(int a1, const char *a2)
{
  unsigned int v2; // r0
  int v3; // r1
  int v5; // [sp+8h] [bp-28h]
  int i; // [sp+14h] [bp-1Ch]
  size_t v9; // [sp+2Ch] [bp-4h]

  v2 = time(0);
  srand(v2);
  for ( i = 0; i < a1; ++i )
  {
    v5 = rand();
    v9 = _strlen_chk(a0123456789abcd, 0x40u);
    sub_2964(v5, v9);
    a2[i] = a0123456789abcd[v3];
  }
  a2[i] = 0;
  return _android_log_print(4, "Crack", "Str:%s", a2);
}
```

å¤§æ¦‚å°±æ˜¯éšæœºç”Ÿæˆå­—ç¬¦ä¸²å¡è¿› a2 æ•°ç»„ï¼Œå†çœ‹çœ‹å‰é¢çš„ sub_1134

```c
int sub_1134()
{
  return 0;
}
```

`return 0`ï¼Œåœ¨æ±‡ç¼–çª—å£å¯ä»¥çœ‹åˆ°ä¸œè¥¿ï¼š

![image-20231211184107875](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231211184107875.png)

æ³¨æ„çœ‹ä¸Šé¢çš„éƒ¨åˆ†ï¼Œå…ˆç»™ R0 èµ‹ 0ï¼Œç„¶åä¸‹é¢ `CMP R0, #0` ç›´æ¥è·³è½¬åˆ° `loc_117c` äº†ã€‚è¯¥å‡½æ•°åç§»åœ°å€ä¸º `0x1134`ï¼Œæˆ‘ä»¬è®©å…¶è¿”å› 1 å°±å¯ä»¥äº†ã€‚

å…ˆè·å– `libcrackme1.so` çš„åŸºåœ°å€ï¼Œè¿™ä¸ªåŸºåœ°å€åŠ ä¸Š` 0x1134` å°±æ˜¯éœ€è¦è¢« hook çš„åœ°å€ï¼Œåœ¨è¿™ä¸ªåœ°å€ä¸Šç›´æ¥è´´ä¸Šè·³è½¬æ±‡ç¼–ä»£ç ï¼Œè·³è½¬åˆ°æˆ‘ä»¬è‡ªå·±å‡½æ•°çš„åœ°å€.

ç°åœ¨è€ƒè™‘è·³è½¬ä»£ç ï¼Œåœ¨ ARM æ¶æ„ä¸­ï¼Œ`MOV` æŒ‡ä»¤ä¸èƒ½ç›´æ¥å°†ä¸€ä¸ªå¤§çš„ç«‹å³æ•°ï¼ˆåœ°å€ï¼‰ç§»åŠ¨åˆ°å¯„å­˜å™¨ï¼Œ`MOV` çš„ç«‹å³æ•°å­—æ®µåªæœ‰ 8 ä½ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ `LDR` æ¥åŠ è½½ä¸€ä¸ª 32 ä½çš„å€¼åˆ°å¯„å­˜å™¨é‡Œï¼Œèµ·åˆ°ä¸€ä¸ªä¸­ä»‹ä½œç”¨ã€‚å¦å¤–åœ¨ ARM æ¶æ„ä¸­ï¼ŒPC å¯„å­˜å™¨æ˜¯æŒ‡å‘**å½“å‰æŒ‡ä»¤ä¹‹åä¸¤æ¡æŒ‡ä»¤çš„åœ°å€**ï¼Œæ‰€ä»¥çœ‹ä¸‹é¢ä»£ç ï¼š

```shell
LDR R0, [PC, #0]
MOV PC, R0
hookFunc
```

æ‰§è¡Œåˆ° `LDR ` è¿™ä¸€å¥çš„æ—¶å€™ï¼ŒPC å¯„å­˜å™¨æŒ‡å‘çš„å€¼å…¶å®å°±æ˜¯ hookFuncã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆæŠŠå‰ä¸¤è¡Œæ±‡ç¼–çš„å­—èŠ‚ç å†™åˆ°è¢« hook å‡½æ•°çš„åœ°å€ï¼Œå†åœ¨åé¢ä¸¤æ¡æŒ‡ä»¤åé¢å†™å…¥ hookFunc çš„åœ°å€

```c
    __memcpy(hooked_addr, shellCode, 0xc);
    __memcpy(hooked_addr + 0x8, &hookFunc, 0x4);
```

[Online ARM to HEX Converter (armconverter.com)](https://armconverter.com/)

`void onload() __attribute__((constructor));` å®šä¹‰äº†ä¸€ä¸ªå‡½æ•° `onload`ï¼Œå½“åŠ¨æ€é“¾æ¥åº“è¢«åŠ è½½æ—¶è‡ªåŠ¨æ‰§è¡Œã€‚

` mprotect(addr, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC);` ä¿®æ”¹ addr æŒ‡å‘çš„å†…å­˜åŒºåŸŸçš„ä¿æŠ¤å±æ€§ï¼Œä½¿å¾—å…¶å¯ä»¥è¢«è¯»å†™æ‰§è¡Œã€‚

å®Œæ•´ä»£ç ï¼š

```c
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include <sys/mman.h>

void onload() __attribute__((constructor));
unsigned char shellCode[0xc] = {0x00, 0x00, 0x9F, 0xE5, 0x00, 0xF0, 0xA0, 0xE1};
int (*android_log_print)(int i, ...);
void *(*memcpy_addr)(void *dst, void *src, size_t n);

int hookFunc() {
    android_log_print(3, "Crack", "hook success");
    printf("Win");
    return 1;
}

void hook() {
    void *addr = NULL;
    unsigned long proc_offset = 0x1134; // è¢«hookå‡½æ•°çš„åç§»åœ°å€
    void *hooked_addr;
    FILE *fp;
    char line[1024];
    char filename[32] = "libcrackme1.so"; // å¯¼å‡ºstringFromJNIçš„so
    snprintf(filename, sizeof(filename), "/proc/self/maps");
    fp = fopen(filename, "rt");
    if (fp != NULL) {
        while (fgets(line, sizeof(line), fp))
            if (strstr(line, filename)) {
                sscanf(line, "%lx", (unsigned long *)(&addr));
                break;
            }
        fclose(fp);
    }
    hooked_addr = (void *)((unsigned long)addr + proc_offset);
    printf("hooked proc at 0x%lx", (unsigned long)hooked_addr);
    mprotect(addr, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC);
    memcpy_addr(hooked_addr, shellCode, 0xc);
    memcpy_addr(hooked_addr + 0x8, &hookFunc, 0x4);
}

void onload() {
    void *handle;
    handle = dlopen("/system/lib/arm/liblog.so", RTLD_LAZY);
    android_log_print = dlsym(handle, "__android_log_print");
    handle = dlopen("/system/lib/arm/libc.so", RTLD_LAZY);
    memcpy_addr = (void *(*)(void *, void *, size_t))dlsym(handle, "memcpy");
    hook();
}

```

## æœŸä¸­ PC ç«¯

> å…¶å®æœŸä¸­è¿˜æœ‰ä¸ªç§»åŠ¨ç«¯ï¼Œä½†æ˜¯æœŸæœ«æ—¶é—´ç´§+ç§»åŠ¨ç«¯å¤ªç—›è‹¦+æˆ‘æ˜¯fwæ‰€ä»¥å°±æ‘†äº†

ida64 æ‰“å¼€ï¼Œç¿»äº†ä¸€åœˆæ²¡çœ‹åˆ°ä»€ä¹ˆä¸œè¥¿ï¼Œè°ƒå¼æ—¶ä¼šæ˜¾ç¤ºâ€œæ£€æµ‹åˆ°è°ƒè¯•â€ç›´æ¥é€€å‡ºï¼Œæ€€ç–‘æ˜¯åŠ å£³äº†ï¼Œæ‹–åˆ° exeinfo çœ‹çœ‹

<img src="https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/QQ%E6%88%AA%E5%9B%BE20231230141101.png" alt="QQæˆªå›¾20231230141101" style="zoom:50%;" />

æç¤ºæ˜¯ vmp åŠ å£³ï¼Œæœäº†ä¸€åœˆå†³å®šå…ˆå¼„ä¸ª x64dbg è¯•è¯•

å°è¯•æ‰¾ä¸€ä¸‹è¾“å…¥è¾“å‡ºåœ¨å“ªï¼Œx64dbg æ‰“å¼€ crackme2.exeï¼Œç¬¦å· â†’ crackme2.exeï¼Œåœ¨å³ä¾§å¯ä»¥çœ‹åˆ°å‡½æ•° APIï¼š

![image-20231230165749765](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230165749765.png)

![image-20231230165758297](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230165758297.png)

æ–­ç‚¹è°ƒè¯•ä¸€æ³¢å‘ç° `WriteFile` åº”è¯¥æ˜¯ç¨‹åºçš„è¾“å‡ºå‡½æ•°ï¼Œé‚£å¯¹åº”çš„è¾“å…¥å°±æ‰¾ `ReadFile` 

<img src="https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230170346190.png" alt="image-20231230170346190" style="zoom:67%;" />

è¿™ä¸ªç¨‹åºå¦‚æœè¾“å…¥å­—ç¬¦ä¸²ä¸æ­£ç¡®çš„è¯ï¼Œä¸ä¼šæ‰“å°ä»»ä½•ä¿¡æ¯ï¼Œå› æ­¤æ²¡æ³•åƒå‰é¢ä½œä¸šä¸€æ ·ç›´æ¥æ‰¾åˆ°ç¨‹åºæœ€åçš„éƒ¨åˆ†ï¼Œè¿˜æ˜¯å…ˆå°è¯•æ‰¾åˆ°ä¸»å‡½æ•°åœ¨å“ªï¼Œæ–­ç‚¹ä¸€ä¸‹ `ReadFile` å’Œ `WriteFile`ï¼Œè§‚å¯Ÿä¸€ä¸‹ï¼š

<img src="https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230184234507.png" alt="image-20231230184234507" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230184324559.png" alt="image-20231230184324559" style="zoom:67%;" /> 

ä¸¤ä¸ªå‡½æ•°æ–­ç‚¹åæŸ¥çœ‹è°ƒç”¨å †æ ˆï¼Œä¸€å¤§ç‰‡è°ƒç”¨ï¼Œéƒ½å¯ä»¥å›æº¯åˆ°åŒä¸€ä¸ªåœ°å€ `140001519` ï¼Œè¿‡å»çœ‹çœ‹ï¼š

![image-20231230185330217](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230185330217.png)

`call crackme2.1400010c0`ï¼Œä¸»å‡½æ•°çš„ä½ç½®åº”è¯¥å°±è¿™äº† `1400010c0`

ä»è¿™ä¸ªåœ°å€å¼€å§‹çš„ä¸‹ä¸€ä¸ªè°ƒç”¨ `140298E12` ( `ReadFile` çš„) å’Œ `140298DF8`  ( `WriteFile` çš„) è¿™ä¿©åœ°å€å¾ˆè¿‘

![image-20231230184752458](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230184752458.png)

åœ¨è¿™ä¸ª `ReadFile` åœ°æ–¹æŸ¥çœ‹æ§åˆ¶æµå›¾ï¼Œä¸­é—´ä¸€å¤§å †å¥‡å¥‡æ€ªæ€ªçš„ä¸œè¥¿çœ‹ä¸æ‡‚ä¸€ç‚¹ï¼Œæ¶¦åˆ°æœ€åï¼Œæ³¨æ„åˆ°ä¸€ä¸ªå¤§åˆ†æ”¯ï¼Œå…¶ä¸­é‡Œé¢éƒ¨åˆ† `call crackme2.140001020`ï¼Œç”±ä¸Šå›¾å¯çŸ¥è¿™ä¸ªæ˜¯ `WriteFile`ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªåœ°æ–¹åº”è¯¥æ˜¯æ‰“å°â€œæ­£ç¡®â€çš„åœ°æ–¹ï¼š

<img src="https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230190415707.png" alt="image-20231230190415707" style="zoom:67%;" />

å¤–é¢çš„éƒ¨åˆ†è°ƒç”¨äº† `Sleep`ï¼Œä¹Ÿå°±æ˜¯ä¸æ­£ç¡®çš„æƒ…å†µï¼ˆç¨‹åºè¿‡äº†ä¸€ä¼šæ‰è‡ªåŠ¨é€€å‡ºï¼‰

å›åˆ°ä¸Šé¢çœ‹è¿™ä¸ªåˆ†æ”¯çš„æ¡ä»¶ï¼š

![image-20231230190445054](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230190445054.png)

å†å¾€ä¸Šåˆ†æä¸€ä¸‹ `eax` å“ªæ¥çš„

<img src="https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230191413390.png" alt="image-20231230191413390" style="zoom:67%;" />

è¿™ä¸ªåœ°æ–¹å¾ªç¯åœ¨ `[rax]` å’Œ `[rax+r8]` å–ä¸€å­—èŠ‚åšæ¯”è¾ƒï¼Œç›¸åŒå°±å‘ä¸‹èµ°æ£€æŸ¥ `[rax+r8]` æ˜¯ä¸æ˜¯ $0$ï¼Œæ˜¯ $0$ å°±è·³å‡ºå¾ªç¯åˆ° `test edx,edx`ï¼Œæ­¤æ—¶ `[rax]` ä¹Ÿè¯¥æ˜¯ $0$ï¼Œå› æ­¤ä¼šè·³åˆ°ä¸‹é¢è¾“å‡ºâ€œæ­£ç¡®â€çš„åœ°æ–¹ã€‚ä¹Ÿå°±æ˜¯è¯´è¿™ä¸ª `[rax+r8]` å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ flagï¼Œæ–­ç‚¹çœ‹çœ‹ï¼š

![image-20231230193800625](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230193800625.png)

`RAX` æ˜¯æˆ‘è¾“å…¥çš„ `testtest`ï¼Œæ‹¿ x64dbg è‡ªå¸¦çš„è®¡ç®—å™¨ç®— `rax+r8`ï¼š

<img src="https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230194453058.png" alt="image-20231230194453058" style="zoom:67%;" />

> çªç„¶å‘ç°ç›´æ¥çª—å£å¤„ä¹Ÿçœ‹åˆ°äº†
> ![image-20231230194533996](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230194533996.png)

flagï¼š`jZiBUViF0WUYwISp4qjx5YwucMNGpb4g`

![image-20231230194613953](https://raw.githubusercontent.com/Akejyo/imageForBlog/master/img/image-20231230194613953.png)
